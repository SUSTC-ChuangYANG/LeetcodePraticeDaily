# 前序遍历,  middle -> left -> right
# 中序遍历,  left -> middle -> right
# 后序遍历,  left -> right -> middle
# 知识点：
1. 为什么函数调用要用栈实现？ https://www.zhihu.com/question/34499262
函数的调用有完美的嵌套关系——调用者的生命期总是长于被调用者的生命期，并且后者在前者的之内。
这样，被调用者的局部信息所占空间的分配总是后于调用者的（后入），而其释放则总是先于调用者的（先出），
所以正好可以满足栈的LIFO顺序，选用栈这种数据结构来实现调用栈是一种很自然的选择。
2. 所有递归都可以改成循环吗？ https://www.zhihu.com/question/20418254
3. 采用栈数据结构的二叉非递归遍历。 http://www.cnblogs.com/hoodlum1980/p/3901359.html


# 我们的目的在于使用栈来复现一个递归的过程， 因此要好好利用栈的原则，先进后出
# 为什么要用栈？ 因为栈可以记录状态, 模拟调用栈。  详见：嵌入式系统与微机原理,栈帧，调用栈
# 模拟调用栈 
____________________________________________________________________________________________

"""
前序 preorder：
node = stack.pop()
	stack.push(right)
	stack.push(left)
一直执行 上边的步骤直到 栈为空
"""
____________________________________________________________________________________________

"""
中序 inorder
while True
	将左子树链条全部压栈
	弹出，打印，并判断是否有右子树，如果有，压栈。
	将根节点更新为右节点
---------------------------------------------	
终止条件，栈空了，没有右子树了： 
    node = stack.pop()
    root = node.right
	if not stack and root is None:
	    break
---------------------------------------------
"""

____________________________________________________________________________________________




